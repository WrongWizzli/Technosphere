ДЗ №1
Выполнил: Вартанов Дмитрий Александрович

===========================================
Как запустить все это дело:

Нужно в консоли прописать команду ./run.sh (возможно, нужно будет еще права выдать скрипту, я выдавал через команду chmod 0755 run.sh)
ИЛИ можно скомпилировать все с помощью g++ main.cpp -std=c++17 -oBoolSearchLink

Выполнение программы: 
    а. Сначала обрабатываются все файлы с ссылками, после в консоль выводится, что можно вводить свой запрос
    б. В запросе можно вводить любые слова и соединять их в запрос с помощью (,),&,| символов. Каждый такой символ должен быть отделен пробелом от слов
       Допускается делать любую вложенность скобок (лишь бы она была корректной)
       Пример запроса: ( Сахар | соль ) & крот & мышь | (( половик & ковер ))
    в. Когда все запросы заданы, через ctrl+D (или аналогичная ему комбинация для конкретной системы) уверенно завершаем программу

===========================================
Что было реализовано:
    1) Базовая часть
    2) Сжатие индексов при помощи VarByte (доп 5 баллов)
    3) Обработка дерева запроса (доп 5 баллов)
    4) Сравнительный анализ (доп 5 баллов)

===========================================
1. Базовая часть

Реализация базовой части содержится в файлике parse_read.hpp
Структурно можно разделить всю базовую часть на два куска: парсинг страниц и разбор поискового запроса
Помимо простого разбора файлика по словам, я добавил урезание окончания в самом его простом виде (убираю с конца все, что не является буквами или цифрами,
а также одну гласную букву или знак, если имеется). Это, хоть и не супер разбор, но тоже хорошо улучшает поиск.

Функции:
1) void mytolower(std::string &s) - сделал свое приведение строки к нижнему регистру, чтобы корректно обрабатывать кириллицу.
2) int cut_word(std::string &word) - функция, убирающая конец слова по правилу, описанному выше. Возвращает новую длину слова (в символах, а не длину строки)
3) bool russian_letter_skip(char v1, char v2) - вспомогательная функция к cut_word() для определения гласной буквы
4) char russian_letter_converter(char v1, char v2)  - вспомогательная функция к russian_letter_skip (приводит буквы к конкретному числу)
5) void parse_file(std::ifstream& rd, std::vector<std::string>& links, std::map<std::string, VarByte>& word_links) -
   Парсинг файла и заполнение вектора ссылок, а также индексов слов
6) bool read_word(std::ifstream& rd, int& word_len, int& pos, const int& max_pos, std::string& word) - чтение слова при парсинга файла
7) bool check_link(const std::string &s) - проверка, является ли выходное слово ссылкой
8) void read_request(std::vector<std::string>& links, std::map<std::string, VarByte>& word_links) - чтение и обработка поискового запроса
9) void read_word_request(std::string::iterator &it, const std::string::iterator &it_end, int& word_len, std::string& word) - чтение слова из поискового запроса
10) std::set<int> get_urls(Operation_Tree &tree, std::vector<VarByte>& v) - получение юрлов, соответсвующих запросу

===========================================
2. VarByte

Реализация его лежит в файлике searchtools.hpp и представляет собой класс VarByte
Идея работы: 
    Создается объект с заданным изначальным размером буффера, а также значением, на которое этот буффер будет расширяться при нехватке места
    Числа добавляются через интервалы между ними (интервал всегда > 0). Это условие позволяет избежать дупликатов и некорректной логики в принципе
    При заполнении объекта можно доставать последовательно значения закодированные

Методы класса:
1) VarByte(int size=100, int e_size=100) - конструктор с размером буффером и шагом расширения
2) Конструкторы копирования и перемещения
3) void expand_size() - расширение памяти в случае, если новое для записи число не помещается в буффер
4) int get_len128(int x) - возвращает длину записи числа (интервала) в 7-битных байтах
5) void add_interval(uint32_t x) - добавляем новое число через интервал. На вход подается исходное число, и интервал считается внутри
6) uint32_t read_next() - прочитать следующее записанное сжатое число
7) void zero_pos() - обнулить сдвиг для чтения чисел
8) std::set<int> get_urls() - возвращает весь список закодированных юрлов

===========================================
3. Дерево разбора запроса

Реализация его лежит в файлике searchtools.hpp и представляет собой класс Operation_Tree

Идея работы:
    1)Создаем объект и записываем операции с учетом их приоритетов при чтении поискового запроса
    2)Обрабатываем слова без юрлов. Это сделано для того, чтобы по возможности выводить хотя бы что-то, ибо лучше что-то, чем ничего :)
      Обработка слов без юрлов заключается в удалении их из дерева. За счет того, что поисковые запросы не должны быть в среднем огромными, такая обработка по перформансу не бьёт
    3)Выдаем нужные запросы без создания промежуточных результатов за счет прогона айдишек через дерево сразу

Методы класса:
1) Конструктор по умолчанию пустой
2) void add_sign(u_char c) - добавляем операцию (,),&,| в дерево запроса
3) void vanish_word() - запоминаем, что прочитали пустое по юрлам слово
4) void existing_word() - запоминаем, что прочитали не пустое по юрлам слово
5) void build_order_tree() - строим дерево на основе инфы об операциях и пустых слов
6) bool process_tree(std::vector<std::pair<bool, bool>> &d) - проверка соответствия юрла запросу
7) std::set<int> get_result(std::vector<VarByte> &v) - получение результата на основе VarByte подходящих слов

Нигде мы не создаем дополнительных больших контейнеров (все создаваемые контейнеры по длине ограничены количеством слов), к чему вроде как и стремились:)

===========================================
4. Сравнительный анализ

Часть 1: VarByte
    1. Объем памяти
    VarByte позволил заметно уменьшить объем используемой памяти. 
    Например, для слова "медведев" удалось записать всю информацию о его айдишках в 300 байт (при наличие ~220 запросов). В случае хранения обычных интов мы имеем 4 * 220 = 880 байт
    Получаем экономию почти в 3 раза! 
    Если же еще учесть, что в инт не бесконечен, получим еще больший прирост при использовании int64_t // class BigInt

    2. Скорость работы
    Запись в VarByte очень быстрая за счет простой записи в чаровский массив. В сравнении с реализацией хранения множества через set и добавления айди туда через insert мы имеем прирост в скорости
    Время обработки 8 файликов на моем ноутбуке (в секундах):
        а. VarByte: 4.27565
        б. Set/insert с int: 6.22508
        в. Set/insert с BigInt: 7.74765
    BigInt - класс, хранящий значения в векторе для возможности записи супербольших чисел

Чвсть 2: Дерево Запроса

    1. Объем памяти:
    Как я писал раньше, мы не используем доп контейнеры размера больше, чем O(кол-во слов в поисковом запросе). За счет этого
    накладные расходы по памяти невелики
    В случае с обычным последовательным выполнением получаем на каждом шаге множество, которое при объединениях может сильно загружать систему

===========================================
5. Выводы

На личном опыте мы получили существенные плюсы при использовании сжатия индексов по памяти и даже скорости (хотя тут скорее вопрос к инсерту множества). Аналогичная ситуация по памяти и с деревом разбора.
Получается, что данные улучшения действительно полезны и применимы для более эффективной и быстрой работы